// Generated by Copilot
const TranscriptRequest = require('../models/transcriptModel');
const logger = require('../utils/logger');

class AnalyticsService {
    async getTranscriptMetrics(startDate, endDate) {
        try {
            const query = {};
            if (startDate || endDate) {
                query.dateOfRequest = {};
                if (startDate) query.dateOfRequest.$gte = new Date(startDate);
                if (endDate) query.dateOfRequest.$lte = new Date(endDate);
            }

            const [
                totalRequests,
                statusDistribution,
                modeDistribution,
                paymentSuccess,
                processingTimes,
                revenueByMode
            ] = await Promise.all([
                // Total number of requests
                TranscriptRequest.countDocuments(query),

                // Distribution by status
                TranscriptRequest.aggregate([
                    { $match: query },
                    { $group: {
                        _id: '$status',
                        count: { $sum: 1 }
                    }}
                ]),

                // Distribution by mode
                TranscriptRequest.aggregate([
                    { $match: query },
                    { $group: {
                        _id: '$modeOfTreatment',
                        count: { $sum: 1 }
                    }}
                ]),

                // Payment success rate
                TranscriptRequest.aggregate([
                    { $match: query },
                    { $group: {
                        _id: null,
                        total: { $sum: 1 },
                        successful: {
                            $sum: {
                                $cond: [
                                    { $eq: ['$status', 'Processing'] },
                                    1,
                                    0
                                ]
                            }
                        }
                    }}
                ]),

                // Processing times analysis
                TranscriptRequest.aggregate([
                    { $match: { ...query, status: 'Completed' } },
                    { $group: {
                        _id: '$modeOfTreatment',
                        averageTime: {
                            $avg: {
                                $divide: [
                                    { $subtract: ['$completedAt', '$dateOfRequest'] },
                                    3600000 // Convert to hours
                                ]
                            }
                        },
                        minTime: {
                            $min: {
                                $divide: [
                                    { $subtract: ['$completedAt', '$dateOfRequest'] },
                                    3600000
                                ]
                            }
                        },
                        maxTime: {
                            $max: {
                                $divide: [
                                    { $subtract: ['$completedAt', '$dateOfRequest'] },
                                    3600000
                                ]
                            }
                        }
                    }}
                ]),

                // Revenue by mode
                TranscriptRequest.aggregate([
                    { $match: query },
                    { $group: {
                        _id: '$modeOfTreatment',
                        totalRevenue: { $sum: '$amount' },
                        count: { $sum: 1 }
                    }}
                ])
            ]);

            // Calculate SLA compliance
            const slaCompliance = {};
            processingTimes.forEach(({ _id: mode, averageTime }) => {
                let targetTime;
                switch (mode) {
                    case 'Super Fast': targetTime = 24;
                        break;
                    case 'Fast': targetTime = 48;
                        break;
                    case 'Normal': targetTime = 720; // 30 days * 24
                        break;
                    case 'Verification': targetTime = 72;
                        break;
                }
                slaCompliance[mode] = averageTime <= targetTime;
            });

            return {
                totalRequests,
                statusDistribution: this.convertToPercentages(statusDistribution),
                modeDistribution: this.convertToPercentages(modeDistribution),
                paymentSuccessRate: paymentSuccess[0] ? 
                    (paymentSuccess[0].successful / paymentSuccess[0].total) * 100 : 0,
                processingTimes: processingTimes.reduce((acc, curr) => {
                    acc[curr._id] = {
                        average: Math.round(curr.averageTime * 100) / 100,
                        min: Math.round(curr.minTime * 100) / 100,
                        max: Math.round(curr.maxTime * 100) / 100
                    };
                    return acc;
                }, {}),
                revenue: revenueByMode.reduce((acc, curr) => {
                    acc[curr._id] = {
                        total: curr.totalRevenue,
                        average: curr.totalRevenue / curr.count
                    };
                    return acc;
                }, {}),
                slaCompliance
            };
        } catch (error) {
            logger.error('Error generating analytics:', error);
            throw new Error('Failed to generate analytics');
        }
    }

    async getPerformanceMetrics() {
        try {
            const now = new Date();
            const lastHour = new Date(now - 3600000);

            const [
                requestsLastHour,
                averageResponseTime,
                errorRate
            ] = await Promise.all([
                // Requests in last hour
                TranscriptRequest.countDocuments({
                    dateOfRequest: { $gte: lastHour }
                }),

                // Average response time (completion time)
                TranscriptRequest.aggregate([
                    {
                        $match: {
                            dateOfRequest: { $gte: lastHour },
                            status: 'Completed'
                        }
                    },
                    {
                        $group: {
                            _id: null,
                            avgTime: {
                                $avg: {
                                    $subtract: ['$completedAt', '$dateOfRequest']
                                }
                            }
                        }
                    }
                ]),

                // Error rate
                TranscriptRequest.aggregate([
                    {
                        $match: {
                            dateOfRequest: { $gte: lastHour }
                        }
                    },
                    {
                        $group: {
                            _id: null,
                            total: { $sum: 1 },
                            failed: {
                                $sum: {
                                    $cond: [
                                        { $eq: ['$status', 'Failed'] },
                                        1,
                                        0
                                    ]
                                }
                            }
                        }
                    }
                ])
            ]);

            return {
                requestsPerHour: requestsLastHour,
                averageResponseTime: averageResponseTime[0]?.avgTime 
                    ? Math.round(averageResponseTime[0].avgTime / 1000) // Convert to seconds
                    : 0,
                errorRate: errorRate[0]
                    ? (errorRate[0].failed / errorRate[0].total) * 100
                    : 0
            };
        } catch (error) {
            logger.error('Error generating performance metrics:', error);
            throw new Error('Failed to generate performance metrics');
        }
    }

    convertToPercentages(distribution) {
        const total = distribution.reduce((sum, item) => sum + item.count, 0);
        return distribution.reduce((acc, item) => {
            acc[item._id] = (item.count / total) * 100;
            return acc;
        }, {});
    }

    async getDailyStats(date = new Date()) {
        try {
            const startOfDay = new Date(date.setHours(0, 0, 0, 0));
            const endOfDay = new Date(date.setHours(23, 59, 59, 999));

            const stats = await TranscriptRequest.aggregate([
                {
                    $match: {
                        dateOfRequest: {
                            $gte: startOfDay,
                            $lte: endOfDay
                        }
                    }
                },
                {
                    $group: {
                        _id: null,
                        totalRequests: { $sum: 1 },
                        totalRevenue: { $sum: '$amount' },
                        completedRequests: {
                            $sum: {
                                $cond: [
                                    { $eq: ['$status', 'Completed'] },
                                    1,
                                    0
                                ]
                            }
                        },
                        failedRequests: {
                            $sum: {
                                $cond: [
                                    { $eq: ['$status', 'Failed'] },
                                    1,
                                    0
                                ]
                            }
                        }
                    }
                }
            ]);

            return stats[0] || {
                totalRequests: 0,
                totalRevenue: 0,
                completedRequests: 0,
                failedRequests: 0
            };
        } catch (error) {
            logger.error('Error generating daily stats:', error);
            throw new Error('Failed to generate daily stats');
        }
    }
}

module.exports = new AnalyticsService();