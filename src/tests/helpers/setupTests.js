// Generated by Copilot
const testDb = require('./testDbConfig');
const emailServiceMock = require('../mocks/emailServiceMock');
const paymentServiceMock = require('../mocks/paymentServiceMock');
const pdfServiceMock = require('../mocks/pdfServiceMock');
const testLogger = require('./testLogger');
const { UserFactory, TranscriptFactory } = require('../factories');

// Mock all services before any tests run
jest.mock('../../services/emailService', () => require('../mocks/emailServiceMock'));
jest.mock('../../services/paymentService', () => require('../mocks/paymentServiceMock'));
jest.mock('../../services/pdfService', () => require('../mocks/pdfServiceMock'));
jest.mock('../../utils/logger', () => require('./testLogger'));

beforeAll(async () => {
    // Set test environment
    process.env.NODE_ENV = 'test';
    
    // Connect to test database
    await testDb.connect();
});

afterAll(async () => {
    // Cleanup
    await testDb.disconnect();
    await pdfServiceMock.cleanupTestFiles();
});

beforeEach(async () => {
    // Reset all mock services before each test
    emailServiceMock.reset();
    paymentServiceMock.reset();
    pdfServiceMock.reset();

    // Clear test database
    await testDb.clearCollections();
});

// Make factories available globally in tests
global.UserFactory = UserFactory;
global.TranscriptFactory = TranscriptFactory;

// Make service mocks available globally in tests
global.emailServiceMock = emailServiceMock;
global.paymentServiceMock = paymentServiceMock;
global.pdfServiceMock = pdfServiceMock;

// Add custom jest matchers
expect.extend({
    toBeValidMongoId(received) {
        const pass = typeof received === 'string' && /^[0-9a-fA-F]{24}$/.test(received);
        return {
            message: () => `expected ${received} to be a valid MongoDB ObjectId`,
            pass
        };
    },
    toHaveBeenCalledWithPattern(mock, pattern) {
        const calls = mock.mock.calls;
        const pass = calls.some(call => pattern.test(JSON.stringify(call)));
        return {
            message: () => `expected mock to have been called with pattern ${pattern}`,
            pass
        };
    }
});

// Add logging to paymentServiceMock
paymentServiceMock.setPaymentSuccessful = (successful) => {
    console.log('Setting payment successful:', successful);
    paymentServiceMock.paymentSuccessful = successful;
    paymentServiceMock.transactions = successful ? [{id: 'test-tx', status: 'success'}] : [];
};

paymentServiceMock.getTransactionCount = () => paymentServiceMock.transactions.length;

paymentServiceMock.getSuccessfulTransactions = () => paymentServiceMock.transactions.filter(t => t.status === 'success');

paymentServiceMock.getPaymentSuccessful = () => {
    console.log('Payment Mock: getPaymentSuccessful', paymentServiceMock.paymentSuccessful);
    return paymentServiceMock.paymentSuccessful;
};

// Add logging to pdfServiceMock
pdfServiceMock.setPdfUrl = (url) => {
    console.log('Setting PDF URL:', url);
    pdfServiceMock.pdfUrl = url;
};

pdfServiceMock.getPdfUrl = () => pdfServiceMock.pdfUrl;

pdfServiceMock.generatePDF = async () => {
    console.log('Generating PDF with URL:', pdfServiceMock.pdfUrl);
    return { url: pdfServiceMock.pdfUrl };
};

// Export test utilities and mocks
module.exports = {
    testDb,
    emailServiceMock,
    paymentServiceMock,
    pdfServiceMock,
    testLogger
};