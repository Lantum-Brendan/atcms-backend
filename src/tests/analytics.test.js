// Generated by Copilot
const { createTestUser, createTranscriptRequest, clearTestData } = require('./helpers/testHelpers');
const analyticsService = require('../services/analyticsService');

describe('Analytics Service Tests', () => {
    let studentUser, requests;

    beforeEach(async () => {
        await clearTestData();
        ({ user: studentUser } = await createTestUser());

        // Create various transcript requests for testing analytics
        requests = await Promise.all([
            // Normal request - Completed
            createTranscriptRequest({
                student: studentUser,
                modeOfTreatment: 'Normal',
                status: 'Completed',
                completedAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // 30 days ago
            }),
            // Super Fast request - Processing
            createTranscriptRequest({
                student: studentUser,
                modeOfTreatment: 'Super Fast',
                status: 'Processing'
            }),
            // Fast request - Completed
            createTranscriptRequest({
                student: studentUser,
                modeOfTreatment: 'Fast',
                status: 'Completed',
                completedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000) // 2 days ago
            }),
            // Verification request - Failed
            createTranscriptRequest({
                student: studentUser,
                modeOfTreatment: 'Verification',
                status: 'Failed'
            })
        ]);
    });

    test('should calculate correct metrics', async () => {
        const startDate = new Date(Date.now() - 60 * 24 * 60 * 60 * 1000); // 60 days ago
        const endDate = new Date();

        const metrics = await analyticsService.getTranscriptMetrics(startDate, endDate);

        expect(metrics.totalRequests).toBe(4);
        
        // Check status distribution
        expect(metrics.statusDistribution).toEqual({
            'Completed': 50, // 2 out of 4
            'Processing': 25, // 1 out of 4
            'Failed': 25 // 1 out of 4
        });

        // Check mode distribution
        expect(metrics.modeDistribution).toEqual({
            'Normal': 25,
            'Super Fast': 25,
            'Fast': 25,
            'Verification': 25
        });

        // Check revenue
        expect(metrics.revenue).toHaveProperty('Normal');
        expect(metrics.revenue.Normal.total).toBe(1000);
        expect(metrics.revenue['Super Fast'].total).toBe(3000);
        expect(metrics.revenue.Fast.total).toBe(2000);
        expect(metrics.revenue.Verification.total).toBe(10000);

        // Check SLA compliance
        expect(metrics.slaCompliance).toHaveProperty('Normal');
        expect(metrics.slaCompliance.Normal).toBe(true);
        expect(metrics.slaCompliance.Fast).toBe(true);
    });

    test('should get accurate performance metrics', async () => {
        const metrics = await analyticsService.getPerformanceMetrics();

        expect(metrics).toHaveProperty('requestsPerHour');
        expect(metrics).toHaveProperty('averageResponseTime');
        expect(metrics).toHaveProperty('errorRate');

        // Since we created requests in the last hour
        expect(metrics.requestsPerHour).toBeGreaterThan(0);
        
        // Error rate should be 25% (1 failed out of 4)
        expect(metrics.errorRate).toBe(25);
    });

    test('should get daily stats', async () => {
        const today = new Date();
        const stats = await analyticsService.getDailyStats(today);

        expect(stats).toHaveProperty('totalRequests');
        expect(stats).toHaveProperty('totalRevenue');
        expect(stats).toHaveProperty('completedRequests');
        expect(stats).toHaveProperty('failedRequests');

        // Check specific values based on our test data
        expect(stats.totalRequests).toBe(4);
        expect(stats.totalRevenue).toBe(16000); // Sum of all request amounts
        expect(stats.completedRequests).toBe(2);
        expect(stats.failedRequests).toBe(1);
    });

    test('should handle date range filtering correctly', async () => {
        // Test last 7 days
        const startDate = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
        const endDate = new Date();

        const metrics = await analyticsService.getTranscriptMetrics(startDate, endDate);

        // Should only include recent requests (excluding the 30-day old one)
        expect(metrics.totalRequests).toBe(3);
        
        // Check processing times for completed requests
        expect(metrics.processingTimes.Fast).toBeDefined();
        expect(metrics.processingTimes.Fast.average).toBeLessThan(48); // Should be under SLA
    });

    test('should calculate revenue metrics correctly', async () => {
        // Create additional requests to test revenue calculations
        await Promise.all([
            createTranscriptRequest({
                student: studentUser,
                modeOfTreatment: 'Super Fast',
                status: 'Completed',
                numberOfCopies: 2 // Testing multiple copies
            }),
            createTranscriptRequest({
                student: studentUser,
                modeOfTreatment: 'Verification',
                status: 'Completed'
            })
        ]);

        const metrics = await analyticsService.getTranscriptMetrics();

        // Check revenue calculations
        expect(metrics.revenue['Super Fast'].total).toBe(9000); // 3000 * 3 (1 + 2 copies)
        expect(metrics.revenue.Verification.total).toBe(20000); // 10000 * 2 requests

        // Check average revenue per request
        expect(metrics.revenue['Super Fast'].average).toBe(4500); // 9000 / 2 requests
        expect(metrics.revenue.Verification.average).toBe(10000); // 20000 / 2 requests
    });
});

describe('Analytics Service Performance Tests', () => {
    let students = [];
    const NUM_REQUESTS = 100;

    beforeAll(async () => {
        // Create test users
        for (let i = 0; i < 5; i++) {
            const { user } = await createTestUser({
                name: `Student ${i}`,
                email: `student${i}@test.com`,
                matricule: `STU${i}001`
            });
            students.push(user);
        }

        // Create many transcript requests
        const requests = [];
        const modes = ['Normal', 'Fast', 'Super Fast', 'Verification'];
        const statuses = ['Processing', 'Completed', 'Failed'];

        for (let i = 0; i < NUM_REQUESTS; i++) {
            const student = students[i % students.length];
            requests.push(createTranscriptRequest({
                student,
                modeOfTreatment: modes[i % modes.length],
                status: statuses[i % statuses.length],
                completedAt: i % 3 === 0 ? new Date() : undefined
            }));
        }

        await Promise.all(requests);
    });

    test('should handle large number of requests efficiently', async () => {
        const startTime = Date.now();
        const metrics = await analyticsService.getTranscriptMetrics();
        const endTime = Date.now();

        expect(metrics.totalRequests).toBe(NUM_REQUESTS + 6); // Including previous test requests
        expect(endTime - startTime).toBeLessThan(1000); // Should complete within 1 second
    });

    test('should calculate accurate statistics with large dataset', async () => {
        const metrics = await analyticsService.getTranscriptMetrics();

        // Verify mode distribution is roughly even
        const modeDistribution = metrics.modeDistribution;
        Object.values(modeDistribution).forEach(percentage => {
            expect(percentage).toBeCloseTo(25, 1); // Should be close to 25% for each mode
        });

        // Verify status distribution is roughly even
        const statusDistribution = metrics.statusDistribution;
        Object.values(statusDistribution).forEach(percentage => {
            expect(percentage).toBeCloseTo(33.33, 1); // Should be close to 33.33% for each status
        });
    });

    test('should maintain performance with concurrent requests', async () => {
        const numConcurrentRequests = 10;
        const startTime = Date.now();

        // Make concurrent analytics requests
        await Promise.all(
            Array(numConcurrentRequests).fill().map(() => 
                analyticsService.getTranscriptMetrics()
            )
        );

        const endTime = Date.now();
        const averageTime = (endTime - startTime) / numConcurrentRequests;

        expect(averageTime).toBeLessThan(200); // Each request should average under 200ms
    });
});