// controllers/transcriptController.js

const catchAsync = require('../utils/catchAsync');
const TranscriptRequest = require('../models/transcriptModel');
const User = require('../models/userModel');
const { validationResult } = require('express-validator');
const paymentService = require('../services/paymentService');
const emailService = require('../services/emailService');
const pdfService = require('../services/pdfService');
const logger = require('../utils/logger');
const PaymentService = require('../services/paymentService');
const PDFService = require('../services/pdfService');

// Generated by Copilot

// Create new transcript request
exports.createTranscriptRequest = catchAsync(async (req, res) => {
  // (Optional) Run express-validator checks if you have them
  if (validationResult(req).errors.length) {
    return res.status(400).json({
      status: 'error',
      message: 'Invalid input data',
      details: validationResult(req).array()
    });
  }

  // Ensure required fields for test data
  // Required: processingTime, amount, paymentDetails, (optional: verifierEmail)
  // processingTime: 'Normal' | 'Fast' | 'Super Fast'
  // amount: 1000 | 2000 | 3000 (or 10000 if verifierEmail present)
  // paymentDetails: { ... }
  // verifierEmail: string (if verification mode)

  const { processingTime, amount, paymentDetails, verifierEmail } = req.body;

  // Validate amount based on processingTime or verification fee
  const fees = {
    'Normal': 1000,
    'Fast': 2000,
    'Super Fast': 3000
  };
  const expectedAmount = verifierEmail ? 10000 : fees[processingTime];
  if (amount !== expectedAmount) {
    return res.status(400).json({
      status: 'error',
      message: verifierEmail
        ? `Invalid amount for verification mode. Expected 10000, got ${amount}`
        : `Invalid amount for selected processing time (${processingTime}). Expected ${expectedAmount}, got ${amount}`
    });
  }

  // Process payment
  try {
    const payment = await PaymentService.processPayment(paymentDetails);
    if (!payment.success) {
      return res.status(400).json({
        error: 'Payment Failed',
        details: payment.error
      });
    }
  } catch (err) {
    return res.status(400).json({
      error: 'Payment Failed',
      details: err.message
    });
  }

  // Create the transcript request, including required fields from the authenticated user
  const transcript = await TranscriptRequest.create({
    ...req.body,
    matricule: req.user.matricule,       // ← populate required field
    studentName: req.user.name,          // ← populate required field
    createdBy: req.user._id,             // ← schema’s required reference
    status: 'Processing'
  });

  return res.status(201).json({
    status: 'success',
    data: transcript
  });
});

// Get student's transcripts
exports.getStudentTranscripts = catchAsync(async (req, res) => {
  if (req.user.role !== 'admin' && req.user.matricule !== req.params.matricule) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You can only view your own transcripts',
      code: 403
    });
  }

  const transcripts = await TranscriptRequest.find({ matricule: req.params.matricule })
    .sort('-dateOfRequest');

  res.json({
    status: 'success',
    data: transcripts
  });
});

// Get transcript by ID
exports.getTranscriptById = catchAsync(async (req, res) => {
  const transcript = await TranscriptRequest.findById(req.params.id);
  if (!transcript) {
    return res.status(404).json({
      error: 'Not Found',
      message: 'Transcript request not found',
      code: 404
    });
  }
  if (req.user.role !== 'admin' && req.user.matricule !== transcript.matricule) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You cannot access this transcript',
      code: 403
    });
  }
  res.json({ status: 'success', data: transcript });
});

// Download transcript PDF
exports.downloadTranscript = catchAsync(async (req, res) => {
  const transcript = await TranscriptRequest.findById(req.params.id);
  if (!transcript) {
    return res.status(404).json({
      error: 'Not Found',
      message: 'Transcript not found',
      code: 404
    });
  }
  if (req.user.role !== 'admin' && req.user.matricule !== transcript.matricule) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You cannot download this transcript',
      code: 403
    });
  }
  if (transcript.status !== 'Completed') {
    return res.status(400).json({
      error: 'Bad Request',
      message: 'Transcript is not ready for download',
      code: 400
    });
  }
  if (!transcript.pdfUrl) {
    return res.status(404).json({
      error: 'Not Found',
      message: 'Transcript PDF not found',
      code: 404
    });
  }
  res.download(transcript.pdfUrl);
});

// Get all transcripts (admin only)
exports.getAllTranscripts = catchAsync(async (req, res) => {
  const { status, mode, fromDate, toDate } = req.query;
  const query = {};
  if (status) query.status = status;
  if (mode) query.modeOfTreatment = mode;
  if (fromDate || toDate) {
    query.dateOfRequest = {};
    if (fromDate) query.dateOfRequest.$gte = new Date(fromDate);
    if (toDate) query.dateOfRequest.$lte = new Date(toDate);
  }

  const transcripts = await TranscriptRequest.find(query)
    .sort('-dateOfRequest')
    .populate('createdBy', 'name email');

  res.json({ status: 'success', data: transcripts });
});

// Update transcript status (admin only)
exports.updateTranscriptStatus = catchAsync(async (req, res) => {
  const { status, comment } = req.body;
  const transcript = await TranscriptRequest.findById(req.params.id);
  if (!transcript) {
    return res.status(404).json({
      error: 'Not Found',
      message: 'Transcript not found',
      code: 404
    });
  }

  transcript.status = status;
  transcript.statusHistory.push({
    status,
    updatedBy: req.user._id,
    comment,
    timestamp: new Date()
  });

  if (status === 'Completed') {
    transcript.completedAt = new Date();

    if (!transcript.pdfUrl) {
      const pdfResult = await pdfService.generateTranscript(transcript);
      transcript.pdfUrl = pdfResult.url;
    }
    transcript.notifications.push({ message: 'Your transcript is ready' });

    if (transcript.modeOfTreatment === 'Verification') {
      await emailService.sendTranscriptToVerifier(transcript.verifierEmail, transcript);
    } else {
      await emailService.sendTranscriptReadyNotification(transcript.createdBy.email, transcript);
    }
  }

  await transcript.save();
  res.json({ status: 'success', data: transcript });
});

// Get statistics (admin only)
exports.getStatistics = catchAsync(async (req, res) => {
  const [
    totalRequests,
    statusCounts,
    modeStats,
    averageProcessingTimes
  ] = await Promise.all([
    TranscriptRequest.countDocuments(),
    TranscriptRequest.aggregate([{ $group: { _id: '$status', count: { $sum: 1 } } }]),
    TranscriptRequest.aggregate([
      { $group: {
          _id: '$modeOfTreatment',
          count: { $sum: 1 },
          revenue: { $sum: '$amount' }
      }}
    ]),
    TranscriptRequest.aggregate([
      { $match: { status: 'Completed' } },
      { $group: {
          _id: '$modeOfTreatment',
          avgProcessingHours: {
            $avg: {
              $divide: [
                { $subtract: ['$completedAt', '$dateOfRequest'] },
                3600000
              ]
            }
          }
      }}
    ])
  ]);

  res.json({
    status: 'success',
    data: {
      totalRequests,
      statusCounts: statusCounts.reduce((acc, curr) => {
        acc[curr._id] = curr.count; return acc;
      }, {}),
      modeStats: modeStats.reduce((acc, curr) => {
        acc[curr._id] = { count: curr.count, revenue: curr.revenue }; return acc;
      }, {}),
      averageProcessingTimes: averageProcessingTimes.reduce((acc, curr) => {
        acc[curr._id] = curr.avgProcessingHours; return acc;
      }, {})
    }
  });
});

// Mark transcript complete (admin only)
exports.markTranscriptComplete = catchAsync(async (req, res) => {
  const transcript = await TranscriptRequest.findById(req.params.id);
  if (!transcript) {
    return res.status(404).json({
      status: 'error',
      message: 'Transcript request not found'
    });
  }

  // Generate PDF and set pdfUrl
  const pdfResult = await PDFService.generateTranscript(transcript);
  transcript.status = 'Completed';
  transcript.pdfDocument = pdfResult.buffer || pdfResult; // keep for legacy
  transcript.pdfUrl = pdfResult.url || pdfResult.pdfUrl || transcript.pdfUrl; // ensure pdfUrl is set
  transcript.completedAt = new Date();
  await transcript.save();

  res.json({
    status: 'success',
    data: {
      id: transcript._id,
      status: transcript.status,
      completedAt: transcript.completedAt,
      pdfUrl: transcript.pdfUrl // Ensure pdfUrl is returned for test
    }
  });
});

// Create a verification-style request (student only)
exports.createVerificationRequest = catchAsync(async (req, res) => {
  const transcript = await TranscriptRequest.findById(req.params.id);
  if (!transcript) {
    return res.status(404).json({
      status: 'error',
      message: 'Transcript request not found'
    });
  }

  transcript.verifierEmail = req.body.verifierEmail;
  transcript.amount = 10000;
  transcript.status = 'Pending Verification';
  await transcript.save();

  res.status(201).json({ status: 'success', data: transcript });
});
const mongoose = require('mongoose');

const transcriptRequestSchema = new mongoose.Schema({
    matricule: {
        type: String,
        required: true,
        uppercase: true,
        index: true
    },
    studentName: {
        type: String,
        required: true
    },
    level: {
        type: String,
        required: true,
        validate: {
            validator: (v) => /^L[2-7]00$/.test(v),
            message: 'Level must be between L200 and L700'
        }
    },
    faculty: {
        type: String,
        required: true
    },
    program: {
        type: String,
        required: true
    },
    semester: {
        type: String,
        required: true,
        enum: ['First Semester', 'Second Semester']
    },
    modeOfTreatment: {
        type: String,
        required: true,
        enum: ['Super Fast', 'Fast', 'Normal', 'Verification']
    },
    processingTime: {
        type: String,
        required: true,
        enum: ['Normal', 'Fast', 'Super Fast']
    },
    amount: {
        type: Number,
        required: true,
        validate: {
            validator: function(value) {
                if (this.verifierEmail) {
                    return value === 10000;
                }
                const fees = {
                    'Normal': 1000,
                    'Fast': 2000,
                    'Super Fast': 3000
                };
                return value === fees[this.processingTime];
            },
            message: 'Amount must match processing time fee'
        }
    },
    dateOfRequest: {
        type: Date,
        default: Date.now,
        index: true
    },
    numberOfCopies: {
        type: Number,
        required: true,
        min: 1
    },
    deliveryMethod: {
        type: String,
        required: true,
        enum: ['Collect from Faculty', 'Email Delivery']
    },
    verifierEmail: {
        type: String,
        required: function() {
            return this.modeOfTreatment === 'Verification';
        },
        validate: {
            validator: function(email) {
                return email ? /^\S+@\S+\.\S+$/.test(email) : true;
            },
            message: 'Invalid verifier email format'
        }
    },
    status: {
        type: String,
        required: true,
        enum: ['Processing', 'Completed', 'Failed'],
        default: 'Processing',
        index: true
    },
    paymentDetails: {
        provider: {
            type: String,
            enum: ['MTN Mobile Money', 'Orange Money'],
            required: true
        },
        phoneNumber: {
            type: String,
            required: true,
            validate: {
                validator: function(v) {
                    return /^\+?[1-9]\d{1,14}$/.test(v);
                },
                message: '{VALUE} is not a valid phone number!'
            }
        },
        transactionId: String,
        paidAt: Date,
        amount: Number
    },
    statusHistory: [{
        status: {
            type: String,
            required: true,
            enum: ['Processing', 'Completed', 'Failed']
        },
        updatedBy: {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'User',
            required: true
        },
        comment: String,
        timestamp: {
            type: Date,
            default: Date.now
        }
    }],
    notifications: [{
        message: {
            type: String,
            required: true
        },
        read: {
            type: Boolean,
            default: false
        },
        createdAt: {
            type: Date,
            default: Date.now
        }
    }],
    pdfUrl: String,
    completedAt: Date,
    createdBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true
    }
}, {
    timestamps: true
});

// Fix: Match enum with schema
transcriptRequestSchema.pre('save', function(next) {
    if (this.isNew || this.isModified('modeOfTreatment')) {
        switch (this.modeOfTreatment) {
            case 'Super Fast':
                this.processingTime = 'Super Fast';
                this.amount = 3000;
                break;
            case 'Fast':
                this.processingTime = 'Fast';
                this.amount = 2000;
                break;
            case 'Normal':
                this.processingTime = 'Normal';
                this.amount = 1000;
                break;
            case 'Verification':
                this.processingTime = 'Normal';
                this.amount = 10000;
                this.deliveryMethod = 'Email Delivery';
                break;
        }
    }
    next();
});

transcriptRequestSchema.virtual('isOverdue').get(function() {
    if (this.status !== 'Processing') return false;
    
    const now = new Date();
    const requestDate = this.dateOfRequest;
    const hours = (now - requestDate) / (1000 * 60 * 60);
    
    switch (this.modeOfTreatment) {
        case 'Super Fast': return hours > 24;
        case 'Fast': return hours > 48;
        case 'Verification': return hours > 72;
        case 'Normal': return hours > (30 * 24);
        default: return false;
    }
});

const TranscriptRequest = mongoose.model('TranscriptRequest', transcriptRequestSchema);
module.exports = TranscriptRequest;
// Generated by Copilot
const { body, validationResult } = require('express-validator');

exports.validateComplaint = [
    body('level')
        .isIn(['L100', 'L200', 'L300', 'L400', 'L500', 'L600', 'L700'])
        .withMessage('Invalid level selected'),
    body('complaintType')
        .notEmpty()
        .withMessage('Complaint type is required'),
    body('courseCode')
        .notEmpty()
        .withMessage('Course code is required'),
    body('subject')
        .notEmpty()
        .withMessage('Subject is required')
        .isLength({ min: 5, max: 100 })
        .withMessage('Subject must be between 5 and 100 characters'),
    body('description')
        .notEmpty()
        .withMessage('Description is required')
        .isLength({ min: 20, max: 1000 })
        .withMessage('Description must be between 20 and 1000 characters'),
    body('semester')
        .isIn(['First Semester', 'First Semester Resit', 'Second Semester', 'Second Semester Resit'])
        .withMessage('Invalid semester selected'),
    (req, res, next) => {
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return res.status(400).json({
                error: 'Validation Error',
                message: 'Invalid input data',
                details: errors.array(),
                code: 400
            });
        }
        next();
    }
];
// Generated by Copilot
const jwt = require('jsonwebtoken');
const User = require('../models/userModel');

exports.protect = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Unauthorized', message: 'No token provided', code: 401 });
    }
    const token = authHeader.split(' ')[1];
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded.id);
    if (!user || user.status !== 'Active') {
      return res.status(401).json({ error: 'Unauthorized', message: 'Invalid or inactive user', code: 401 });
    }
    req.user = user;
    next();
  } catch (err) {
    return res.status(401).json({ error: 'Unauthorized', message: 'Invalid token', code: 401 });
  }
};

exports.restrictTo = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You do not have permission to perform this action',
        code: 403
      });
    }
    next();
  };
};
// routes/transcriptRoutes.js

const express = require('express');
const router = express.Router();
const transcriptController = require('../controllers/transcriptController');
const { protect, restrictTo } = require('../middleware/authMiddleware');
const catchAsync = require('../utils/catchAsync');
const { body } = require('express-validator');

// Validation middleware
const validateTranscriptRequest = [
  body('level')
    .matches(/^L[2-7]00$/)
    .withMessage('Level must be between L200 and L700'),
  body('faculty')
    .notEmpty()
    .withMessage('Faculty is required'),
  body('program')
    .notEmpty()
    .withMessage('Program is required'),
  body('semester')
    .isIn(['First Semester', 'Second Semester'])
    .withMessage('Invalid semester'),
  body('modeOfTreatment')
    .isIn(['Super Fast', 'Fast', 'Normal', 'Verification'])
    .withMessage('Invalid mode of treatment'),
  body('numberOfCopies')
    .isInt({ min: 1 })
    .withMessage('Number of copies must be at least 1'),
  body('verifierEmail')
    .if(body('modeOfTreatment').equals('Verification'))
    .isEmail()
    .withMessage('Valid verifier email is required for verification mode'),
  body('paymentDetails.provider')
    .isIn(['MTN Mobile Money', 'Orange Money'])
    .withMessage('Invalid payment provider'),
  body('paymentDetails.phoneNumber')
    .matches(/^\+?[1-9]\d{1,14}$/)
    .withMessage('Invalid phone number format')
];

// Protect all routes
router.use(protect);

// Student route: request a transcript
router.post(
  '/request',
  restrictTo('student'),          // <-- use string, not array
  validateTranscriptRequest,
  catchAsync(transcriptController.createTranscriptRequest)
);

// Get student's transcripts
router.get(
  '/student/:matricule',
  catchAsync(transcriptController.getStudentTranscripts)
);

// Get a single transcript by ID
router.get(
  '/:id',
  catchAsync(transcriptController.getTranscriptById)
);

// Download transcript PDF
router.get(
  '/:id/download',
  catchAsync(transcriptController.downloadTranscript)
);

// Admin routes
router.get(
  '/',
  restrictTo('admin'),            // <-- use string
  catchAsync(transcriptController.getAllTranscripts)
);

router.put(
  '/:id/status',
  restrictTo('admin'),            // <-- use string
  body('status')
    .isIn(['Processing', 'Completed', 'Failed'])
    .withMessage('Invalid status'),
  catchAsync(transcriptController.updateTranscriptStatus)
);

router.get(
  '/statistics',
  restrictTo('admin'),
  catchAsync(transcriptController.getStatistics)
);

// Mark transcript complete (admin)
router.patch(
  '/:id/complete',
  restrictTo('admin'),
  transcriptController.markTranscriptComplete
);

// Create verification request (student)
router.post(
  '/:id/verify',
  restrictTo('student'),
  catchAsync(transcriptController.createVerificationRequest)
);

module.exports = router;
// Generated by Copilot
const logger = require('../utils/logger');

// Mock mobile money API configuration - replace with actual API keys in production
const config = {
    mtn: {
        apiKey: process.env.MTN_API_KEY || 'test_mtn_key',
        apiSecret: process.env.MTN_API_SECRET || 'test_mtn_secret',
        baseUrl: process.env.MTN_API_URL || 'https://sandbox.mtn.com/api'
    },
    orange: {
        apiKey: process.env.ORANGE_API_KEY || 'test_orange_key',
        apiSecret: process.env.ORANGE_API_SECRET || 'test_orange_secret',
        baseUrl: process.env.ORANGE_API_URL || 'https://sandbox.orange.com/api'
    }
};

class PaymentService {
    async processPayment({ amount, provider, phoneNumber, description }) {
        try {
            let paymentResult;

            switch (provider) {
                case 'MTN Mobile Money':
                    paymentResult = await this.processMTNPayment(amount, phoneNumber, description);
                    break;
                case 'Orange Money':
                    paymentResult = await this.processOrangePayment(amount, phoneNumber, description);
                    break;
                default:
                    throw new Error('Unsupported payment provider');
            }

            return {
                success: true,
                transactionId: paymentResult.transactionId,
                message: 'Payment processed successfully'
            };

        } catch (error) {
            logger.error('Payment processing error:', error);
            return {
                success: false,
                message: error.message || 'Payment processing failed'
            };
        }
    }

    async processMTNPayment(amount, phoneNumber, description) {
        // TODO: Replace with actual MTN Mobile Money API integration
        try {
            // Simulate API call
            const response = await this.simulatePaymentAPI('MTN', amount, phoneNumber);
            
            if (!response.success) {
                throw new Error(response.message);
            }

            return {
                transactionId: response.transactionId,
                status: 'completed',
                provider: 'MTN Mobile Money'
            };
        } catch (error) {
            throw new Error(`MTN Payment failed: ${error.message}`);
        }
    }

    async processOrangePayment(amount, phoneNumber, description) {
        // TODO: Replace with actual Orange Money API integration
        try {
            // Simulate API call
            const response = await this.simulatePaymentAPI('Orange', amount, phoneNumber);
            
            if (!response.success) {
                throw new Error(response.message);
            }

            return {
                transactionId: response.transactionId,
                status: 'completed',
                provider: 'Orange Money'
            };
        } catch (error) {
            throw new Error(`Orange Money Payment failed: ${error.message}`);
        }
    }

    async simulatePaymentAPI(provider, amount, phoneNumber) {
        // Simulate payment processing delay
        await new Promise(resolve => setTimeout(resolve, 2000));

        // Simulate successful payment 90% of the time
        const isSuccess = Math.random() < 0.9;

        if (isSuccess) {
            return {
                success: true,
                transactionId: `${provider}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                message: 'Payment successful'
            };
        } else {
            return {
                success: false,
                message: 'Payment failed: Insufficient funds'
            };
        }
    }

    async verifyPayment(transactionId) {
        // TODO: Implement payment verification with provider APIs
        try {
            // Simulate verification delay
            await new Promise(resolve => setTimeout(resolve, 1000));

            return {
                verified: true,
                status: 'completed',
                timestamp: new Date()
            };
        } catch (error) {
            logger.error('Payment verification error:', error);
            throw new Error('Payment verification failed');
        }
    }

    async getPaymentStatus(transactionId) {
        // TODO: Implement payment status check with provider APIs
        try {
            // Simulate status check
            return {
                status: 'completed',
                transactionId,
                timestamp: new Date()
            };
        } catch (error) {
            logger.error('Payment status check error:', error);
            throw new Error('Payment status check failed');
        }
    }
}

module.exports = new PaymentService();
// Generated by Copilot
class PaymentServiceMock {
    constructor() {
        this.transactions = [];
        this.successRate = 1; // Default 100% success rate
    }

    reset() {
        this.transactions = [];
        this.successRate = 1;
    }

    setSuccessRate(rate) {
        this.successRate = Math.max(0, Math.min(1, rate));
    }

    async processPayment(amount, details) {
        const success = Math.random() < this.successRate;
        const transaction = {
            id: `TEST_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            amount,
            details,
            status: success ? 'success' : 'failed',
            timestamp: new Date(),
            provider: details.provider
        };

        this.transactions.push(transaction);

        if (!success) {
            throw new Error('Payment Failed');
        }

        return transaction;
    }

    getTransactionCount() {
        return this.transactions.length;
    }

    getSuccessfulTransactions() {
        return this.transactions.filter(t => t.status === 'success');
    }

    getFailedTransactions() {
        return this.transactions.filter(t => t.status === 'failed');
    }

    getTransactionsByProvider(provider) {
        return this.transactions.filter(t => t.provider === provider);
    }

    async validatePayment(transactionId) {
        const transaction = this.transactions.find(t => t.id === transactionId);
        return transaction ? transaction.status === 'success' : false;
    }

    async refundPayment(transactionId, amount) {
        const transaction = this.transactions.find(t => t.id === transactionId);
        if (!transaction) {
            throw new Error('Transaction not found');
        }

        const refund = {
            ...transaction,
            id: `REFUND_${transaction.id}`,
            originalTransactionId: transaction.id,
            amount: amount || transaction.amount,
            status: 'refunded',
            timestamp: new Date()
        };

        this.transactions.push(refund);
        return refund;
    }

    async getPaymentMethods() {
        return [
            { id: 'mtn', name: 'MTN Mobile Money', enabled: true },
            { id: 'orange', name: 'Orange Money', enabled: true }
        ];
    }

    getLastTransaction() {
        return this.transactions[this.transactions.length - 1] || null;
    }
}

module.exports = new PaymentServiceMock();
