// Generated by Copilot
const request = require('supertest');
const mongoose = require('mongoose');
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../.env.test') });
const app = require('../app');
const { UserFactory, TranscriptFactory } = require('../src/tests/factories');
const { pdfServiceMock } = require('../src/tests/helpers/setupTests');

let server;

beforeAll(async () => {
    server = app.listen(0);
    await mongoose.connect(process.env.MONGO_URI);
});

afterAll(async () => {
    await mongoose.connection.close();
    await server.close();
    await pdfServiceMock.cleanupTestFiles();
});

describe('Transcript Download and Verification', () => {
    describe('Transcript Download', () => {
        let studentToken, adminToken, student, admin, transcript;

        beforeEach(async () => {
            ({ user: student, token: studentToken } = await UserFactory.createStudent());
            ({ user: admin, token: adminToken } = await UserFactory.createAdmin());

            transcript = await TranscriptFactory.create({
                studentName: student.name,
                matricule: student.matricule,
                faculty: student.faculty,
                program: student.program,
                createdBy: student._id,
                status: 'Completed',
                pdfUrl: '/uploads/transcripts/test.pdf'
            });
        });

        test('student can download their completed transcript', async () => {
            const response = await request(server)
                .get(`/api/transcripts/${transcript._id}/download`)
                .set('Authorization', `Bearer ${studentToken}`);

            expect(response.status).toBe(200);
            expect(response.headers['content-type']).toBe('application/pdf');
            expect(response.headers['content-disposition']).toContain('attachment');
        });

        test('student cannot download incomplete transcript', async () => {
            const pendingTranscript = await TranscriptFactory.create({
                studentName: student.name,
                matricule: student.matricule,
                createdBy: student._id,
                status: 'Processing'
            });

            const response = await request(server)
                .get(`/api/transcripts/${pendingTranscript._id}/download`)
                .set('Authorization', `Bearer ${studentToken}`);

            expect(response.status).toBe(400);
            expect(response.body.error).toBe('Transcript not ready for download');
        });

        test('student cannot download another student\'s transcript', async () => {
            const otherStudent = await UserFactory.createStudent();
            const response = await request(server)
                .get(`/api/transcripts/${transcript._id}/download`)
                .set('Authorization', `Bearer ${otherStudent.token}`);

            expect(response.status).toBe(403);
        });

        test('admin can download any completed transcript', async () => {
            const response = await request(server)
                .get(`/api/transcripts/${transcript._id}/download`)
                .set('Authorization', `Bearer ${adminToken}`);

            expect(response.status).toBe(200);
            expect(response.headers['content-type']).toBe('application/pdf');
        });
    });

    describe('Transcript Verification', () => {
        let adminToken, student, verificationTranscript;
        const verifierEmail = 'verifier@company.com';

        beforeEach(async () => {
            ({ user: student } = await UserFactory.createStudent());
            ({ token: adminToken } = await UserFactory.createAdmin());

            verificationTranscript = await TranscriptFactory.createVerificationRequest(
                verifierEmail,
                {
                    studentName: student.name,
                    matricule: student.matricule,
                    createdBy: student._id,
                    status: 'Completed'
                }
            );
        });

        test('should verify transcript signature', async () => {
            const response = await request(server)
                .post(`/api/transcripts/verify/${verificationTranscript._id}`)
                .send({ signature: verificationTranscript.signature });

            expect(response.status).toBe(200);
            expect(response.body.data.verified).toBe(true);
        });

        test('should reject invalid signature', async () => {
            const response = await request(server)
                .post(`/api/transcripts/verify/${verificationTranscript._id}`)
                .send({ signature: 'invalid_signature' });

            expect(response.status).toBe(400);
            expect(response.body.error).toBe('Invalid signature');
        });

        test('should track verification attempts', async () => {
            await request(server)
                .post(`/api/transcripts/verify/${verificationTranscript._id}`)
                .send({ signature: verificationTranscript.signature });

            const verificationHistory = await request(server)
                .get(`/api/transcripts/${verificationTranscript._id}/verification-history`)
                .set('Authorization', `Bearer ${adminToken}`);

            expect(verificationHistory.status).toBe(200);
            expect(verificationHistory.body.data).toHaveLength(1);
            expect(verificationHistory.body.data[0]).toHaveProperty('verifiedAt');
            expect(verificationHistory.body.data[0]).toHaveProperty('ipAddress');
        });

        test('should handle expired verification links', async () => {
            // Create an expired verification transcript
            const expiredTranscript = await TranscriptFactory.createVerificationRequest(
                verifierEmail,
                {
                    studentName: student.name,
                    matricule: student.matricule,
                    createdBy: student._id,
                    status: 'Completed',
                    verificationExpiry: new Date(Date.now() - 24 * 60 * 60 * 1000) // 1 day ago
                }
            );

            const response = await request(server)
                .post(`/api/transcripts/verify/${expiredTranscript._id}`)
                .send({ signature: expiredTranscript.signature });

            expect(response.status).toBe(400);
            expect(response.body.error).toBe('Verification link expired');
        });
    });

    describe('Bulk Download', () => {
        let adminToken, admin;

        beforeEach(async () => {
            ({ user: admin, token: adminToken } = await UserFactory.createAdmin());
            
            // Create multiple completed transcripts
            const students = await UserFactory.createManyStudents(3);
            for (const student of students) {
                await TranscriptFactory.createMany(2, {
                    studentName: student.name,
                    matricule: student.matricule,
                    createdBy: student._id,
                    status: 'Completed',
                    pdfUrl: `/uploads/transcripts/${student.matricule}_test.pdf`
                });
            }
        });

        test('admin can download multiple transcripts as zip', async () => {
            const response = await request(server)
                .post('/api/transcripts/bulk-download')
                .set('Authorization', `Bearer ${adminToken}`)
                .send({
                    fromDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
                    toDate: new Date().toISOString()
                });

            expect(response.status).toBe(200);
            expect(response.headers['content-type']).toBe('application/zip');
            expect(response.headers['content-disposition']).toContain('attachment');
        });

        test('student cannot access bulk download', async () => {
            const { token: studentToken } = await UserFactory.createStudent();

            const response = await request(server)
                .post('/api/transcripts/bulk-download')
                .set('Authorization', `Bearer ${studentToken}`)
                .send({
                    fromDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
                    toDate: new Date().toISOString()
                });

            expect(response.status).toBe(403);
        });
    });
});